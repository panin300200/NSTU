#include <iostream>


using std::cin;
using std::cout;
using std::endl;


// статическая очередь (динамический массив)
class QueueS {
private:


    // n - размерность. begin - первый элемент(индекс). end - последний элемент(индекс).
    int n = NULL, begin = -1, end = begin;
    char* ch; // как сделать тип который захочет пользователь?


public:


    // очистить очередь
    void clear() {
        begin = -1;
        end = begin;
    }


    // задать размерность очереди
    void size(int a) {
        n = a;
        ch = new char[n];
        clear();
    }


    // удаление памяти под матрицу
    void del() {
        if(n == NULL)
            delete[] ch;
    }


    // проверка на пустоту
    bool empty() {
        return !(bool)(begin + 1);
    }


    // проверка: есть место или нет
    bool has_size() {
        if (empty())
            return true;
        return end + 1 != n;
    }


    // взятие первого элемента
    char pop(char s) {
        if (!empty()) {
            s = ch[begin];
            for (int i = 0; i < end; i++) {
                ch[i] = ch[i + 1];
            }
            end--;
            if (begin > end)
                clear();
            return s;
        }
        return '\0';
    }


    // значение первого элемента
    char getf() {
        if (!empty())
            return ch[begin];
        return '\0';
    }


    // значение последнего элемента
    char getl() {
        if (!empty())
            return ch[end];
        return '\0';
    }


    // добавить элемент в очередь
    void push(char s) {
        ch[++end] = s;
        if (empty())
            begin = end;
    }


    //распечатать очередь
    void print() {
        if (!empty())
            for (int i = begin; i < end + 1; i++)
                cout << ch[i] << ' ';
        cout << endl << endl;;
    }


    // ж) - функция приоритета очереди
    void priority() {

        if (!empty()) {
            char* copy_ch = new char[end - begin + 1]; // массив


            // копирование массив
            for (int i = begin; i < end - begin + 1; i++)
                copy_ch[i] = ch[i];


            for (int i = begin; i < end; i++) {
                for (int k = i + 1; k < end - begin + 1; k++) {
                    if (ch[i] > copy_ch[k]) {
                        ch[k] = ch[i];
                        ch[i] = copy_ch[k];
                        copy_ch[k] = ch[k];
                    }
                }
            }


            // очистка копии и вывод оснв. массив
            delete[] copy_ch;
            print();
        }
    }


};


// класс динамической очереди (двухсвязный циклический список с заглавным звеном)
class QueueD {


private:


    //список двухсвязный
    struct list {
        char data;
        list* next, * prev;
    }  *end = nullptr, * p = end, * del;


    //создание первого элемента
    void create(char s) {
        end = new list;
        p = end;
        end->data = s;
        end->next = p;
        end->prev = p;


    }


public:


    //проверка на пустоту / если пусто вернет true
    bool is_empty() {
        return end == nullptr;
    }


    //новый элемент
    void push(char s) {
        if (is_empty())
            create(s);
        else {
            end->next = new list;
            end->next->prev = end;
            end = end->next;
            end->next = p;
            p->prev = end;
            end->data = s;
        }
    }


    //получить первый элемент;
    char getf() {
        if (!is_empty()) {
            return p->data;
        }
        return '\0';
    }


    //получить последний элемент
    char getl() {
        if(!is_empty()) {
            return p->prev->data;
        }
        return '\0';
    }


    //взять элемент
    char pop(char s) {
        if (!is_empty()) {
            s = p->data;
            del = p;
            if (p == p->next) {
                end = nullptr;
                p = end;
            }
            else {
                p = p->next;
                p->prev = end;
                end->next = p;
            }
            delete del;
            return s;
        }
        return '\0';
    }


    //oчистить очередь
    void clear() {
        for (end = p->next; end != p; del = end, end = end->next, delete del);
        delete p;
        end = nullptr;
        p = end;
    }


    //распечатать очередь
    void print() {
        for (end = p; end->next != p; end = end->next) {
            cout << end->data << ' ';
        }
        cout << end->data << ' ' << endl;
    }


};
